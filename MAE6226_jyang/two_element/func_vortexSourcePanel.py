import math
import numpy
from scipy import integrate

def stream_function(self, X, Y):
      """Computes the stream-function generated by a doublet.
      Arguments
      ---------
      X, Y -- mesh grid.
      """
      self.psi = -self.strength/(2*math.pi)*(Y-self.y)/((X-self.x)**2+(Y-self.y)**2)


class Freestream:
    """Freestream conditions."""
    def __init__(self, u_inf=1.0, alpha=0.0):
       """Sets the freestream conditions.

       Arguments
       ---------
       u_inf -- Farfield speed (default 1.0).
       alpha -- Angle of attack in degrees (default 0.0).
       """
       self.u_inf = u_inf
       self.alpha = alpha*math.pi/180          # degrees --> radians

class Panel:
    def __init__(self, xa, ya, xb, yb):
        self.xa, self.ya = xa, ya
        self.xb, self.yb = xb, yb
        self.xc, self.yc = (xa+xb)/2, (ya+yb)/2
        self.length = numpy.sqrt((xb-xa)**2+(yb-ya)**2)
        if xb-xa <= 0.:
            self.beta = numpy.arccos((yb-ya)/self.length)
        elif xb-xa > 0.:
            self.beta = numpy.pi + numpy.arccos(-(yb-ya)/self.length)

        # project to normal and tangential direction
        self.nx = numpy.cos(self.beta)
        self.ny = numpy.sin(self.beta)
        self.tx = -numpy.sin(self.beta)
        self.ty = numpy.cos(self.beta)

        if self.beta <= numpy.pi:
            self.loc = 'extrados'
        else:
            self.loc = 'intrados'

        self.sigma = 0.
        self.vt = 0.
        self.cp = 0.


def integral(p_i, panel, a, b):
    """Evaluates the contribution of a panel at one point.
    Arguments
    ---------
    p_i -- the target panel
    panel -- panel which contribution is evaluated.

    Returns
    -------
    Integral over the panel of the influence at one point.
    """
    def f(s):
        return ( ((p_i.xc - (panel.xa - numpy.sin(panel.beta)*s))*a
               + (p_i.yc - (panel.ya + numpy.cos(panel.beta)*s))*b)
               / ((p_i.xc - (panel.xa - numpy.sin(panel.beta)*s))**2
               + (p_i.yc - (panel.ya + numpy.cos(panel.beta)*s))**2) )

    return integrate.quad(lambda s:f(s), 0., panel.length)[0]

def source_matrix(panels):
    """build the N*N source coefficient matrix"""
    a = numpy.zeros((panels.size, panels.size), dtype=float)
    numpy.fill_diagonal(a, 0.5)
    for i, p_i in enumerate(panels):
        for j, p_j in enumerate(panels):
            if i!=j:
                a[i, j] = 0.5/numpy.pi*integral(p_i, p_j, p_i.nx, p_i.ny)
    return a

def vortex_array(panels):
    """return N*2 vortex coefficient array"""
    N = panels.size
    mains = panels[:N/2]
    flaps = panels[N/2:]
    a = numpy.zeros((N, 2), dtype=float)
    # loop in evaluation panel i
    for i, p_i in enumerate(panels):
        # loop in main airfoil panel j
        for j, p_j in enumerate(mains):
            if i != j:    # jump if i,j are the same panel
                a[i, 0] -= 0.5/numpy.pi*integral(p_i, p_j, p_i.ny, - p_i.nx)
        # loop in flap airfoil panel j
        for j, p_j in enumerate(flaps):
            if i != (j+N/2):    # jump if i,j are the same panel
                a[i, 1] -= 0.5/numpy.pi*integral(p_i, p_j, p_i.ny, - p_i.nx)
    return a

def kutta_array(panels, a, b):
    """return N+2 x 1 array for main airfoil"""
    p_a, p_b = panels[a], panels[b]
    N = panels.size
    mains = panels[:N/2]
    flaps = panels[N/2:]
    A = numpy.zeros(N+2, dtype=float)

    # calculate the coefficient of source strength
    for j, p_j in enumerate(panels):
        if j != a:
            A[j] += 0.5/numpy.pi * integral(p_a, p_j, p_a.tx, p_a.ty)
        if j != b:
            A[j] += 0.5/numpy.pi * integral(p_b, p_j, p_b.tx, p_b.ty)

    # calculate the coefficient of vortex strength
    # if a,b on main airfoil
    if b <= N/2-1:
        # main airfoil
        for j, p_j in enumerate(mains):
            if j != a:
                A[-2] -= 0.5/numpy.pi * integral(p_a, p_j, p_a.ty, -p_a.tx)
            else:
                A[-2] -= 0.5
            if j != b:
                A[-2] -= 0.5/numpy.pi * integral(p_b, p_j, p_b.ty, -p_b.tx)
            else:
                A[-2] -= 0.5
        # flap airfoil
        for j, p_j in enumerate(flaps):
            A[-1] -= 0.5/numpy.pi * integral(p_a, p_j, p_a.ty, -p_a.tx)
            A[-1] -= 0.5/numpy.pi * integral(p_b, p_j, p_b.ty, -p_b.tx)

    # if a,b on flap airfoil
    elif a >= N/2:
        # main airfoil
        for j, p_j in enumerate(mains):
            A[-2] -= 0.5/numpy.pi * integral(p_a, p_j, p_a.ty, -p_a.tx)
            A[-2] -= 0.5/numpy.pi * integral(p_b, p_j, p_b.ty, -p_b.tx)
        # flap airfoil
        for j, p_j in enumerate(flaps):
            if (j+N/2) != a:
                A[-1] -= 0.5/numpy.pi * integral(p_a, p_j, p_a.ty, -p_a.tx)
            else:
                A[-1] -= 0.5
            if (j+N/2) !=b :
                A[-1] -= 0.5/numpy.pi * integral(p_b, p_j, p_b.ty,-p_b.tx)
            else:
                A[-1] -= 0.5

    return A

def build_matrix(panels):
    N = panels.size
    A = numpy.empty((N+2, N+2), dtype=float)
    AS = source_matrix(panels)
    av = vortex_array(panels)
    k1 = kutta_array(panels, 0, N/2-1)
    k2 = kutta_array(panels, N/2, N-1)

    A[:N, :N] = AS[:,:]
    A[:N, N:] = av[:,:]
    A[-2, :] = k1[:]
    A[-1, :] = k2[:]

    return A

def build_rhs(panels, freestream):
    N = panels.size
    b = numpy.zeros(N+2, dtype=float)
    for i, p_i in enumerate(panels):
        b[i] = - freestream.u_inf * numpy.cos(freestream.alpha - p_i.beta)

    # kutta condition main airfoil
    b[-2] = -freestream.u_inf * (numpy.sin(freestream.alpha-panels[0].beta)
                + numpy.sin(freestream.alpha-panels[N/2-1].beta))
    # kutta condition flap airfoil
    b[-1] = -freestream.u_inf * (numpy.sin(freestream.alpha-panels[N/2].beta)
                + numpy.sin(freestream.alpha-panels[N-1].beta))
    return b

def get_tangential_velocity(panels, freestream, gamma):
    """Computes the tangential velocity on the surface.

    Arguments
    ---------
    panels -- array of panels.
    freestream -- farfield conditions.
    gamma -- circulation density.
    """
    N = len(panels)
    A = numpy.empty((N, N+1), dtype=float)
    numpy.fill_diagonal(A, 0.0)

    for i, p_i in enumerate(panels):
        # contribution from vortex on itself
        A[i, N] = -0.5
        for j, p_j in enumerate(panels):
            if i != j:
                # contribution from the sources
                A[i,j] = 0.5/math.pi*integral(p_i.xc, p_i.yc,
                                              p_j,
                                              -math.sin(p_i.beta), math.cos(p_i.beta))
                # contribution the vortices
                A[i,N] -= 0.5/math.pi*integral(p_i.xc, p_i.yc,
                                               p_j,
                                               math.cos(p_i.beta), math.sin(p_i.beta))

    b = freestream.u_inf * numpy.sin([freestream.alpha - panel.beta for panel in panels])

    var = numpy.append([panel.sigma for panel in panels], gamma)

    vt = numpy.dot(A, var) + b
    for i, panel in enumerate(panels):
        panel.vt = vt[i]

def get_tangential_vel(panels, freestream, solution):
    """Calculate the tangential velocity for each panel"""
    N = len(panels)
    mains = panels[:N/2]
    flaps = panels[N/2:]
    A = numpy.zeros((N, N+2), dtype=float)
    b = numpy.zeros(N, dtype=float)
    for i, p_i in enumerate(panels):
        # freestream
        b[i] = freestream.u_inf * numpy.sin(freestream.alpha-p_i.beta)
        # source
        for j, p_j in enumerate(panels):
            if i != j:
                A[i, j] = 0.5/numpy.pi *integral(p_i, p_j, p_i.tx, p_i.ty)
        # vortex
        # i on main
        if i < N/2:
            # main wing contribution
            for j, p_j in enumerate(mains):
                if i != j:
                    A[i, -2] -= 0.5/numpy.pi * integral(p_i, p_j, p_i.ty, -p_i.tx)
                else:
                    A[i, -2] -= 0.5
            # flap wing contribution
            for j, p_j in enumerate(flaps):
                A[i, -1] -= 0.5/numpy.pi * integral(p_i, p_j, p_i.ty, -p_i.tx)
                # i on flap
        else:
            # main wing contribution
            for j, p_j in enumerate(mains):
                A[i,-2] -= 0.5/numpy.pi * integral(p_i, p_j, p_i.ty, -p_i.tx)
            # flap contribution
            for j, p_j in enumerate(flaps):
                if i != (j+N/2):
                    A[i,-1] -= 0.5/numpy.pi * integral(p_i, p_j, p_i.ty, -p_i.tx)
                else:
                    A[i,-1] -= 0.5

    vt = numpy.dot(A, solution) + b
    for i, panel in enumerate(panels):
        panel.vt = vt[i]

def get_pressure_coefficient(panels, freestream):
    """Computes the surface pressure coefficients.

    Arguments
    ---------
    panels -- array of panels.
    freestream -- farfield conditions.
    """
    for panel in panels:
        panel.cp = 1.0 - (panel.vt/freestream.u_inf)**2


def get_velocity_field(panels, freestream, X, Y):
    """Returns the velocity field.

    Arguments
    ---------
    panels -- array of panels.
    freestream -- farfield conditions.
    X, Y -- mesh grid.
    """
    Nx, Ny = X.shape
    u, v = numpy.empty((Nx, Ny), dtype=float), numpy.empty((Nx, Ny), dtype=float)

    for i in xrange(Nx):
        for j in xrange(Ny):
            u[i,j] = freestream.u_inf*math.cos(freestream.alpha)\
                     + 0.5/math.pi*sum([p.sigma*integral(X[i,j], Y[i,j], p, 1, 0) for p in panels])
            v[i,j] = freestream.u_inf*math.sin(freestream.alpha)\
                     + 0.5/math.pi*sum([p.sigma*integral(X[i,j], Y[i,j], p, 0, 1) for p in panels])

    return u, v
